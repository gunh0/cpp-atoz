# C++ A to Z

### Hangul Automata

**Example code for understanding \*automata**

> \*Automata: A field of computer science that academically approaches abstract machines capable of computation and the problems that can be solved using these machines.

This example code demonstrates a simple implementation of a Hangul (Korean characters) Automata. An automaton (plural: automata) in computer science is an abstract machine that can be in one of a finite number of states. The machine can change from one state to another in response to some external inputs. This concept is used in designing software and hardware systems of various complexity levels, such as compilers, digital circuits, and artificial intelligence algorithms.

The Hangul Automata illustrated in this example is designed to recognize patterns within a given set of Korean text inputs. It categorizes characters into consonants (J), vowels (M), and other characters (O) based on their roles in forming Korean syllables. Through this process, the automaton can perform tasks such as parsing input text, identifying syllable boundaries, or even checking for valid Korean words or phrases. This type of automaton can be particularly useful in applications involving natural language processing (NLP), text analysis, and educational tools designed to assist in learning the Korean language.

The key concepts demonstrated in this code include:

-   **State Transitions**: How the automaton moves from one state to another based on the input character's classification (consonant, vowel, or other).
-   **Pattern Recognition**: The ability to recognize specific sequences of characters that form valid Korean syllables.
-   **Input Processing**: Taking a series of characters as input and processing them through the automaton to produce a meaningful output.

This example serves as a basic introduction to the principles of automata theory and its application in computational linguistics and language processing. It showcases how automata can be constructed to process and analyze text in specific languages, providing insights into the fundamental mechanisms behind more complex language processing systems.

<br/>

<br/>

### C++ STL Programming

**Operator Overloading**

-   `01_intPlus.cpp`
-   `04_PlusOperatorDefine.cpp`
-   `06_PlusOperatorFuncion.cpp`
-   `08_PlusPlusOperation.cpp`
-   `09_'--'OperationOverloading.cpp`
-   `10_'=='OperationOverloading.cpp`
-   `11_'!='OperationOverloading.cpp`
-   `12_MemberFunctionOP'-'Overloading.cpp`
-   `13_GlobalFunctionOP'-'Overloading.cpp`
-   `14_PrintINT.cpp`
-   `15_FuncOverloading.cpp`
-   `16_ArrayIndexOperOverloading.cpp`
-   `17_INTSavingArray.cpp`

<br/>

<br/>

### C++ Socket Test

This project is dedicated to demonstrating practical applications of C++ socket programming for network communications. It includes examples of setting up a basic client-server architecture, where the server listens for connections on a specified port, and the client connects to the server to exchange messages.

<br/>

<br/>

### Beginning C++17 From Novice to Professional

**1. Basic Ideas**

1. A complete Cpp program
2. Using escape sequences

**2. Introducting Functional Type of Data**

1. Writing values of various to cout
2. Converting distances
3. Sizing a pond for happy fish
4. Using explicit type conversoins
5. Finding maximum and minimum values for data types

**3. Working with Fundamental Data Types**

1. Using the bitwise operators
2. Operations with enumerations
3. Demonstrating scope, lifetime, and global variables

**4. Making Decisions**

1. Comparing data values

**5. Arrays and Loops**

1. Using a for loop with an array

**6. Pointers and References**

1. The size of pointers
2. Dereferencing pointers
3. Initializing pointers with strings
4. Using an array of pointers
5. Calculating primes using pointer notation
6. Calculating primes using dynamic memory allocation
7. Using smart pointers

**7. Working with Classes**

1. Concatenating strings
2. Accessing characters in a string
3. Comparing strings
4. Searching within strings
